# 逻辑设计说明书

------

## 1 设计准则与总体规范

- 数据库：`OnlineBookStore`（字符集 `utf8mb4`，排序规则 `utf8mb4_general_ci`）。
- 存储引擎：**InnoDB**（支持事务、外键、行级锁）。
- 命名规范：表名复数或单数均一致采用 CamelCase（本说明中使用 PascalCase，如 `Book`, `Customer`）。列名使用驼峰或下划线混用，但本稿以驼峰为主。
- 主键：大多数表使用 `INT AUTO_INCREMENT`。复合主键用于多对多联系表。
- 时间字段统一使用 `DATETIME`。
- 密码字段必须保存哈希值（应用层负责哈希并加盐）。
- 所有外键显式声明，并根据业务选择 `ON DELETE`/`ON UPDATE` 行为（下文说明）。
- 为常用查询建立合适索引与全文索引（书名、关键字、作者）。

------

## 2 建库与初始化

```sql
CREATE DATABASE IF NOT EXISTS OnlineBookStore
  CHARACTER SET = utf8mb4
  COLLATE = utf8mb4_general_ci;
USE OnlineBookStore;
```

------

## 3 表结构

> 下列 DDL 已包含主键、外键、约束与常用索引。可逐条执行。

### 3.1 Book（书目）

```sql
CREATE TABLE Book (
  BookID INT PRIMARY KEY AUTO_INCREMENT,
  Title VARCHAR(200) NOT NULL,
  Publisher VARCHAR(100),
  Price DECIMAL(10,2) NOT NULL CHECK (Price >= 0),
  StockQuantity INT NOT NULL DEFAULT 0,
  Catalog TEXT,
  CoverImage LONGBLOB,
  SeriesID INT,
  Location VARCHAR(100),
  CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
  UpdatedAt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FULLTEXT KEY fx_book_title (Title)
) ENGINE=InnoDB;
```

说明：对 Title 建 `FULLTEXT`，便于模糊/自然语言检索。

------

### 3.2 Author 与 BookAuthor

```sql
CREATE TABLE Author (
  AuthorID INT PRIMARY KEY AUTO_INCREMENT,
  Name VARCHAR(100) NOT NULL,
  CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

CREATE TABLE BookAuthor (
  BookID INT NOT NULL,
  AuthorID INT NOT NULL,
  AuthorOrder TINYINT NOT NULL CHECK (AuthorOrder BETWEEN 1 AND 4),
  PRIMARY KEY (BookID, AuthorID),
  FOREIGN KEY (BookID) REFERENCES Book(BookID) ON DELETE CASCADE ON UPDATE CASCADE,
  FOREIGN KEY (AuthorID) REFERENCES Author(AuthorID) ON DELETE RESTRICT ON UPDATE CASCADE
) ENGINE=InnoDB;
CREATE INDEX idx_bookauthor_bookid ON BookAuthor(BookID);
```

------

### 3.3 Keyword 与 BookKeyword

```sql
CREATE TABLE Keyword (
  KeywordID INT PRIMARY KEY AUTO_INCREMENT,
  Word VARCHAR(50) NOT NULL,
  UNIQUE KEY ux_keyword_word (Word)
) ENGINE=InnoDB;

CREATE TABLE BookKeyword (
  BookID INT NOT NULL,
  KeywordID INT NOT NULL,
  PRIMARY KEY (BookID, KeywordID),
  FOREIGN KEY (BookID) REFERENCES Book(BookID) ON DELETE CASCADE,
  FOREIGN KEY (KeywordID) REFERENCES Keyword(KeywordID) ON DELETE CASCADE
) ENGINE=InnoDB;
CREATE FULLTEXT INDEX fx_keyword_word ON Keyword(Word);
```

------

### 3.4 Supplier 与 BookSupplier

```sql
CREATE TABLE Supplier (
  SupplierID INT PRIMARY KEY AUTO_INCREMENT,
  Name VARCHAR(200) NOT NULL,
  Address VARCHAR(300),
  Phone VARCHAR(50),
  ContactEmail VARCHAR(100),
  CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

CREATE TABLE BookSupplier (
  BookID INT NOT NULL,
  SupplierID INT NOT NULL,
  SupplyPrice DECIMAL(10,2),
  PRIMARY KEY (BookID, SupplierID),
  FOREIGN KEY (BookID) REFERENCES Book(BookID) ON DELETE CASCADE,
  FOREIGN KEY (SupplierID) REFERENCES Supplier(SupplierID) ON DELETE CASCADE
) ENGINE=InnoDB;
```

------

### 3.5 Customer

```sql
CREATE TABLE Customer (
  CustomerID INT PRIMARY KEY AUTO_INCREMENT,
  Email VARCHAR(150) UNIQUE NOT NULL,
  PasswordHash VARCHAR(255) NOT NULL,
  Name VARCHAR(200),
  Address VARCHAR(300),
  Balance DECIMAL(12,2) DEFAULT 0,
  CreditLevel TINYINT DEFAULT 1 CHECK (CreditLevel BETWEEN 1 AND 5),
  MonthlyLimit DECIMAL(12,2) DEFAULT 0,
  CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
  LastLogin DATETIME
) ENGINE=InnoDB;
CREATE INDEX idx_customer_email ON Customer(Email);
```

说明：`PasswordHash` 存储哈希（如 bcrypt）。

------

### 3.6 Orders 与 OrderItem

```sql
CREATE TABLE Orders (
  OrderID INT PRIMARY KEY AUTO_INCREMENT,
  CustomerID INT NOT NULL,
  OrderDate DATETIME DEFAULT CURRENT_TIMESTAMP,
  ShippingAddress VARCHAR(300),
  TotalAmount DECIMAL(12,2) DEFAULT 0,
  Status VARCHAR(50) DEFAULT 'Pending',
  FOREIGN KEY (CustomerID) REFERENCES Customer(CustomerID) ON DELETE RESTRICT
) ENGINE=InnoDB;
CREATE INDEX idx_orders_customer ON Orders(CustomerID);

CREATE TABLE OrderItem (
  OrderID INT NOT NULL,
  BookID INT NOT NULL,
  Quantity INT NOT NULL CHECK (Quantity > 0),
  UnitPrice DECIMAL(10,2) NOT NULL,
  Amount DECIMAL(12,2) AS (Quantity * UnitPrice) STORED,
  PRIMARY KEY (OrderID, BookID),
  FOREIGN KEY (OrderID) REFERENCES Orders(OrderID) ON DELETE CASCADE,
  FOREIGN KEY (BookID) REFERENCES Book(BookID) ON DELETE RESTRICT
) ENGINE=InnoDB;
CREATE INDEX idx_orderitem_bookid ON OrderItem(BookID);
```

说明：`Amount` 为生成列，可保持一致性；`TotalAmount` 由应用/存储过程维护。

------

### 3.7 Shipment

```sql
CREATE TABLE Shipment (
  ShipmentID INT PRIMARY KEY AUTO_INCREMENT,
  OrderID INT NOT NULL,
  BookID INT NOT NULL,
  Quantity INT NOT NULL,
  ShipDate DATETIME DEFAULT CURRENT_TIMESTAMP,
  Carrier VARCHAR(100),
  TrackingNo VARCHAR(100),
  FOREIGN KEY (OrderID) REFERENCES Orders(OrderID) ON DELETE CASCADE,
  FOREIGN KEY (BookID) REFERENCES Book(BookID) ON DELETE RESTRICT
) ENGINE=InnoDB;
CREATE INDEX idx_shipment_order ON Shipment(OrderID);
```

------

### 3.8 ShortageRecord

```sql
CREATE TABLE ShortageRecord (
  ShortageID INT PRIMARY KEY AUTO_INCREMENT,
  BookID INT NOT NULL,
  SupplierID INT,
  CustomerID INT,
  Quantity INT NOT NULL,
  Date DATETIME DEFAULT CURRENT_TIMESTAMP,
  SourceType VARCHAR(50),
  Processed TINYINT DEFAULT 0,
  FOREIGN KEY (BookID) REFERENCES Book(BookID) ON DELETE CASCADE,
  FOREIGN KEY (SupplierID) REFERENCES Supplier(SupplierID) ON DELETE SET NULL,
  FOREIGN KEY (CustomerID) REFERENCES Customer(CustomerID) ON DELETE SET NULL
) ENGINE=InnoDB;
CREATE INDEX idx_shortage_book ON ShortageRecord(BookID);
```

------

### 3.9 PurchaseOrder 与 PurchaseItem

```sql
CREATE TABLE PurchaseOrder (
  POID INT PRIMARY KEY AUTO_INCREMENT,
  SupplierID INT NOT NULL,
  CreateDate DATETIME DEFAULT CURRENT_TIMESTAMP,
  Status VARCHAR(50) DEFAULT 'Created',
  FOREIGN KEY (SupplierID) REFERENCES Supplier(SupplierID) ON DELETE RESTRICT
) ENGINE=InnoDB;

CREATE TABLE PurchaseItem (
  POID INT NOT NULL,
  BookID INT NOT NULL,
  Quantity INT NOT NULL,
  PRIMARY KEY (POID, BookID),
  FOREIGN KEY (POID) REFERENCES PurchaseOrder(POID) ON DELETE CASCADE,
  FOREIGN KEY (BookID) REFERENCES Book(BookID) ON DELETE RESTRICT
) ENGINE=InnoDB;
```

## **4. 视图设计**

以下视图直接对应系统必须提供的查询功能（书目展示 / 客户信息查询 / 历史订单 / 发货信息）。

------

### **4.1 v_book_basic_info（书目基础信息视图）**

```sql
CREATE VIEW v_book_basic_info AS
SELECT 
    b.BookID,
    b.Title,
    b.Publisher,
    b.Price,
    b.StockQuantity
FROM Book b;
```

必要性：客户侧浏览书目时使用，避免暴露内部字段（Catalog、CoverImage等）。

------

### **4.2 v_book_detail（书目详情视图）**

```sql
CREATE VIEW v_book_detail AS
SELECT 
    b.BookID,
    b.Title,
    b.Publisher,
    b.Price,
    GROUP_CONCAT(DISTINCT a.Name ORDER BY ba.AuthorOrder SEPARATOR ', ') AS Authors,
    GROUP_CONCAT(DISTINCT k.Word SEPARATOR ', ') AS Keywords,
    b.StockQuantity
FROM Book b
LEFT JOIN BookAuthor ba ON b.BookID = ba.BookID
LEFT JOIN Author a ON ba.AuthorID = a.AuthorID
LEFT JOIN BookKeyword bk ON b.BookID = bk.BookID
LEFT JOIN Keyword k ON bk.KeywordID = k.KeywordID
GROUP BY b.BookID;
```

必要性：客户查询书目详情或管理员维护书目使用。

------

### **4.3 v_customer_info（客户基础信息视图）**

```sql
CREATE VIEW v_customer_info AS
SELECT 
    CustomerID,
    Name,
    Address,
    Balance,
    CreditLevel
FROM Customer;
```

必要性：管理员查看客户列表和信用等级。

------

### **4.4 v_customer_orders（客户历史订单视图）**

```sql
CREATE VIEW v_customer_orders AS
SELECT
    o.OrderID,
    o.CustomerID,
    o.OrderDate,
    o.Status,
    o.TotalAmount
FROM Orders o;
```

必要性：客户查询订单历史；管理员查看订单状态。

------

### **4.5 v_order_items_detail（订单明细视图）**

```sql
CREATE VIEW v_order_items_detail AS
SELECT
    oi.OrderID,
    b.Title,
    oi.BookID,
    oi.Quantity,
    oi.UnitPrice,
    oi.Amount
FROM OrderItem oi
JOIN Book b ON oi.BookID = b.BookID;
```

必要性：订单页面展示每一项商品。

------

### **4.6 v_shipment_detail（发货明细视图）**

```sql
CREATE VIEW v_shipment_detail AS
SELECT
    s.ShipmentID,
    s.OrderID,
    s.BookID,
    b.Title,
    s.Quantity,
    s.ShipDate,
    s.TrackingNo
FROM Shipment s
JOIN Book b ON s.BookID = b.BookID;
```

必要性：客户查询发货记录；管理员查看发货情况。

------

## **5.必要存储过程（含事务）**

存储过程均包含事务，用于保证一致性。
 这些是系统必需的后台操作：
 下订单
  采购入库
 更新订单总金额

------

### **5.1 下订单（CreateOrder）**

**包含库存校验、扣减、信用校验、缺书记录生成**
 完全符合网上书店订购流程要求

```sql
DELIMITER $$

CREATE PROCEDURE CreateOrder(
    IN pCustomerID INT,
    IN pShippingAddress VARCHAR(300)
)
BEGIN
    DECLARE vOrderID INT;

    START TRANSACTION;

    -- 创建订单主表记录
    INSERT INTO Orders(CustomerID, ShippingAddress) 
    VALUES(pCustomerID, pShippingAddress);

    SET vOrderID = LAST_INSERT_ID();

    -- OrderItem 表中的订单项内容由业务层提前插入到临时表 temp_order_item
    -- 结构：BookID, Quantity

    -- 插入订单项
    INSERT INTO OrderItem(OrderID, BookID, Quantity, UnitPrice)
    SELECT 
        vOrderID AS OrderID,
        t.BookID,
        t.Quantity,
        b.Price
    FROM temp_order_item t
    JOIN Book b ON t.BookID = b.BookID;

    -- 更新库存
    UPDATE Book b
    JOIN temp_order_item t ON b.BookID = t.BookID
    SET b.StockQuantity = b.StockQuantity - t.Quantity;

    -- 自动生成缺书记录
    INSERT INTO ShortageRecord(BookID, Quantity, Date, SourceType)
    SELECT 
        b.BookID,
        ABS(b.StockQuantity),
        NOW(),
        'Order'
    FROM Book b
    WHERE b.StockQuantity < 0;

    COMMIT;
END$$

DELIMITER ;
```

------

### **5.2 采购到货（ReceivePurchase）**

```sql
DELIMITER $$

CREATE PROCEDURE ReceivePurchase(
    IN pPOID INT
)
BEGIN
    START TRANSACTION;

    -- 更新库存
    UPDATE Book b
    JOIN PurchaseItem pi ON b.BookID = pi.BookID
    SET b.StockQuantity = b.StockQuantity + pi.Quantity
    WHERE pi.POID = pPOID;

    -- 更新采购单状态
    UPDATE PurchaseOrder
    SET Status = 'Arrived'
    WHERE POID = pPOID;

    -- 标记相关缺书记录已处理
    UPDATE ShortageRecord sr
    JOIN PurchaseItem pi ON sr.BookID = pi.BookID
    SET sr.Processed = 1
    WHERE pi.POID = pPOID;

    COMMIT;
END$$

DELIMITER ;
```

------

### **5.3 更新订单总金额（UpdateOrderTotal）**

```sql
DELIMITER $$

CREATE PROCEDURE UpdateOrderTotal(
    IN pOrderID INT
)
BEGIN
    UPDATE Orders
    SET TotalAmount = (
        SELECT SUM(Amount)
        FROM OrderItem
        WHERE OrderID = pOrderID
    )
    WHERE OrderID = pOrderID;
END$$

DELIMITER ;
```

------

##  **6.触发器（Triggers）**

下面为系统必须具备的触发器逻辑：

------

### **6.1 自动维护订单总金额**

> 当订单明细插入或更新时自动更新 `Orders.TotalAmount`

```sql
CREATE TRIGGER trg_orderitem_update_total
AFTER INSERT ON OrderItem
FOR EACH ROW
CALL UpdateOrderTotal(NEW.OrderID);
```

------

### **6.2 自动扣减库存（不需要等到存储过程）**

```sql
CREATE TRIGGER trg_after_orderitem_insert
AFTER INSERT ON OrderItem
FOR EACH ROW
UPDATE Book
SET StockQuantity = StockQuantity - NEW.Quantity
WHERE BookID = NEW.BookID;
```

------

### **6.3 自动生成缺书记录**

```sql
CREATE TRIGGER trg_shortage_auto
AFTER UPDATE ON Book
FOR EACH ROW
BEGIN
    IF NEW.StockQuantity < 0 THEN
        INSERT INTO ShortageRecord(BookID, Quantity, Date, SourceType)
        VALUES(NEW.BookID, ABS(NEW.StockQuantity), NOW(), 'Auto');
    END IF;
END;
```

------

### **6.4 自动增加库存（采购入库）**

```sql
CREATE TRIGGER trg_after_purchase_item
AFTER INSERT ON PurchaseItem
FOR EACH ROW
UPDATE Book
SET StockQuantity = StockQuantity + NEW.Quantity
WHERE BookID = NEW.BookID;
```

## **7. 索引策略与性能考虑**

本实验的数据规模不大，但系统包含 **多表关联查询（订单 → 订单项 → 书目）、书目检索、缺书查询、供应商查询**，因此索引策略必须服务如下高频操作：

------

### **7.1 面向“查询书目”的索引**

用户在前端需要支持快速搜索书籍（按标题、关键字），因此建立：

- `FULLTEXT (Title)` 于 **Book**
- `FULLTEXT (Word)` 于 **Keyword**

用于：

- 模糊搜索书名
- 按关键字查找书籍
- 后台管理员查找书籍信息

本实验书目查询频率最高，该索引能显著提升检索效率。

------

### **7.2 面向“订单相关查询”的索引**

后台及用户会频繁执行：

- 查询某个客户的所有订单
- 从订单定位到订单项
- 从订单项跳转到书籍详情

因此建立以下普通索引：

- **Orders(CustomerID)**：快速查询客户订单
- **OrderItem(OrderID)**：快速获取订单明细
- **OrderItem(BookID)**：后台统计某书的总销量

这些索引直接对应系统业务操作，属于实验必须项。

------

### **7.3 面向“缺书与采购处理”的索引**

缺书记录的后台管理需要快速检查某本书的缺书历史：

- **ShortageRecord(BookID)**：按书目查询所有缺书记录
- **PurchaseItem(BookID)**：按书目查询采购情况

避免在缺书处理页面全表扫描。

------

### **7.4 面向“浏览书目列表 + 页面翻页”的索引**

前端经常按 BookID 排序并分页显示书目，因此：

- `Book(BookID)` 为主键，可支撑稳定的分页
- 推荐分页方式：`WHERE BookID > last_id`

避免使用大 OFFSET，适合本实验数据逐渐增长的特点。

------

### **7.5 无需建立的索引**

- `(BookID, StockQuantity)`
- `(SupplierID, Price)`

因为实验中不涉及此类组合查询，也无数据量要求，不建立可减少维护成本。

------

##  **8. 事务与并发控制**

本实验核心涉及两类并发敏感操作：

**① 下单 → 扣库存**

**② 采购到货 → 增库存**

这两个环节必须确保库存不会出现竞态，事务设计完全围绕这两点展开。

------

### **8.1 下订单事务逻辑（本实验关键事务）**

当用户下订单时，系统会：

1. 插入订单（Orders）
2. 插入订单项（OrderItem）
3. 扣减库存（Book.StockQuantity）
4. 如库存不足 → 自动生成缺书记录

以上四个步骤必须在 **一个事务中完成**，否则可能导致：

- 库存减少但订单未生成
- 订单项生成但库存未扣减
- 同时下单导致库存变为负数却未记录缺书

因此必须：

```sql
START TRANSACTION;
...
SELECT StockQuantity FOR UPDATE;
...
COMMIT;
```

行锁只锁定“被购买的书籍记录”，完全符合实验库存模型。

------

### **8.2 采购到货事务（与下单相对、保证库存一致性）**

采购入库涉及：

1. 更新 Book 库存
2. 更新采购单状态
3. 标记相关缺书记录已处理

三步之间不能出现中断，否则库存、采购状态与缺书记录会不一致，因此也必须写入同一事务中。

------

### **8.3 隔离级别选择**

本实验的业务流程中：

- 库存扣减必须读到最新值
- 缺书记录生成必须确保准确
- 订单创建要求可重复读

因此维持 MySQL 默认的 **REPEATABLE READ** 即可满足要求。

不需要 SERIALIZABLE，因为实验中不会出现复杂的统计或多表更新场景。

------

### **8.4 避免长事务**

实验中所有高并发风险仅在库存处理，操作本身简单：

- 一个订单不会包含大量订单项
- 一个订单不会跨多秒执行

因此应 **在库存处理前准备好所有数据**，避免在事务内部做没有必要的计算或等待。

------

##  **9. 安全与权限**

本实验属于“教学业务系统”，但仍必须避免：

- 学生误删表结构
- 应用程序批量操作表结构
- 明文密码泄露

因此权限设计如下：

------

### **9.1 仅为应用分配运行时权限**

应用用户（如 Web 系统）仅需：

- SELECT
- INSERT
- UPDATE
- DELETE
- EXECUTE（若使用存储过程）

禁止：

- CREATE / DROP / ALTER
- GRANT / RELOAD / SHUTDOWN

避免应用层误删实验数据结构。

------

### **9.2 管理员权限与应用权限分离**

实验管理员账号：

- 用于创建表结构、触发器、过程
- 不对前端应用开放

应用账号：

- 仅操作业务数据
- 不接触结构数据

这也是本实验在多组同学同时操作数据库时避免损坏环境的重要策略。

------

### **9.3 密码安全**

由于客户表 Customer 需要存储密码字段：

- 必须存储 **密码哈希值（如 SHA-256 + Salt）**
- 不允许存储明文密码（即使是实验）

课程实验通常评分标准中会检查是否有“明文密码”的设计问题。

------

### **9.4 后台敏感数据访问限制**

以下字段应仅由后台管理系统访问：

- Customer.Balance
- Customer.CreditLevel
- Supplier 联系方式
- 所有缺书记录

前端普通用户不可直接查询这些信息，避免实验中出现越权漏洞。

------

##  **10. 备份、恢复与维护建议**

实验环境通常为：

- 多次测试运行
- 学生可能误操作
- 表结构可能被破坏
- 订单数据需要随时恢复

因此备份与恢复策略需专门面向实验特点。

------

### **10.1 备份**

实验环境建议采用：

- 每日一次逻辑备份（mysqldump）
- 备份数据库结构 + 数据
- 学生操作前自动备份

推荐开启：

```sql
mysqldump --single-transaction OnlineBookStore > backup.sql
```

用于保证一致性快照并支持在线备份。

------

### **10.2 恢复策略**

在以下情况下恢复备份：

- 表结构损坏（触发器/过程丢失）
- 数据被批量误删
- 实验中多次调试导致数据混乱

恢复方法：

```sql
mysql OnlineBookStore < backup.sql
```

恢复应在测试库完成验证后再覆盖主库。

------

### **10.3 数据归档（针对本实验的“数据增长模式”）**

实验中订单表与发货表会随着测试增加数据，为了使查询更快：

- 每个实验阶段结束后，可将旧订单复制到 `Orders_History`
- 主表仅保留最近的数据（如最近 2 周）

减少主表扫描，有助于同学们更快速验证查询结果。

------

### **10.4 表维护**

- 经常执行 `ANALYZE TABLE` 优化查询计划
- 定期清理调试用的临时订单、临时缺书记录
- 若使用 FULLTEXT，需要在大量更新后执行 `OPTIMIZE TABLE`

确保在多轮测试后系统仍然运行流畅。